// =======================
// deploy-server/server.js
// (Upload + Packages + WS Routing + Winget Catalog add/search)
// =======================
'use strict';

const path = require('path');
const fs = require('fs');
const http = require('http');
const crypto = require('crypto');

const express = require('express');
const multer = require('multer');
const WebSocket = require('ws');

const PORT = process.env.PORT ? Number(process.env.PORT) : 8787;
const AGENT_TOKEN = process.env.AGENT_TOKEN || 'supersecret';

// Admin token für Catalog-Änderungen (nur Admin darf Apps hinzufügen)
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || 'adminsecret';

const app = express();
app.use(express.json());

const dataDir = path.join(__dirname, 'data');
const pkgDir = path.join(dataDir, 'packages');
const tmpDir = path.join(dataDir, 'tmp');
const metaFile = path.join(dataDir, 'packages.json');
const catalogFile = path.join(dataDir, 'catalog.json');

fs.mkdirSync(pkgDir, { recursive: true });
fs.mkdirSync(tmpDir, { recursive: true });
if (!fs.existsSync(metaFile)) fs.writeFileSync(metaFile, JSON.stringify([], null, 2));
if (!fs.existsSync(catalogFile)) {
  // Default Catalog (du kannst jederzeit erweitern)
  fs.writeFileSync(catalogFile, JSON.stringify([
    { id: "Mozilla.Firefox", name: "Firefox", defaultScope: "user" },
    { id: "7zip.7zip", name: "7-Zip", defaultScope: "user" },
    { id: "VideoLAN.VLC", name: "VLC", defaultScope: "user" },
    { id: "Notepad++.Notepad++", name: "Notepad++", defaultScope: "user" }
  ], null, 2));
}

function readPackages() {
  return JSON.parse(fs.readFileSync(metaFile, 'utf-8'));
}
function writePackages(pkgs) {
  fs.writeFileSync(metaFile, JSON.stringify(pkgs, null, 2));
}

function readCatalog() {
  return JSON.parse(fs.readFileSync(catalogFile, 'utf-8'));
}
function writeCatalog(catalog) {
  fs.writeFileSync(catalogFile, JSON.stringify(catalog, null, 2));
}

function sha256File(filePath) {
  return new Promise((resolve, reject) => {
    const h = crypto.createHash('sha256');
    const s = fs.createReadStream(filePath);
    s.on('data', (d) => h.update(d));
    s.on('end', () => resolve(h.digest('hex')));
    s.on('error', reject);
  });
}

// --------- HTTP ---------
app.get('/health', (req, res) => res.json({ ok: true }));

app.use('/', express.static(path.join(__dirname, 'public')));

app.use('/packages', express.static(pkgDir, {
  setHeaders(res) {
    res.setHeader('Content-Disposition', 'attachment');
  }
}));

// Upload endpoint (Installer Upload)
const upload = multer({ dest: tmpDir });
app.post('/api/upload', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ ok: false, error: 'no file' });

    const original = req.file.originalname;
    const ext = path.extname(original).toLowerCase();
    const safeBase = path.basename(original).replace(/[^\w.\-() ]+/g, '_');

    const id = crypto.randomUUID();
    const finalName = `${id}_${safeBase}`;
    const finalPath = path.join(pkgDir, finalName);

    fs.renameSync(req.file.path, finalPath);

    const hash = await sha256File(finalPath);
    const stat = fs.statSync(finalPath);

    const pkgs = readPackages();
    const pkg = {
      id,
      name: req.body.name?.trim() || safeBase,
      version: req.body.version?.trim() || '',
      filename: finalName,
      sizeBytes: stat.size,
      sha256: hash,
      createdAt: new Date().toISOString(),
      typeHint: ext === '.msi' ? 'msi' : 'exe'
    };
    pkgs.push(pkg);
    writePackages(pkgs);

    broadcastDashboards({ type: 'packages', packages: pkgs });

    res.json({ ok: true, pkg });
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

app.get('/api/packages', (req, res) => {
  res.json({ ok: true, packages: readPackages() });
});

// Catalog GET
app.get('/api/catalog', (req, res) => {
  res.json({ ok: true, catalog: readCatalog() });
});

// Catalog ADD (admin only)
function requireAdmin(req, res, next) {
  const token = req.header('x-admin-token') || '';
  if (token !== ADMIN_TOKEN) return res.status(403).json({ ok: false, error: 'forbidden' });
  next();
}

app.post('/api/catalog/add', requireAdmin, (req, res) => {
  const id = String(req.body?.id || '').trim();
  const name = String(req.body?.name || '').trim() || id;
  const defaultScope = (String(req.body?.defaultScope || 'user').trim().toLowerCase() === 'machine') ? 'machine' : 'user';

  if (!id) return res.status(400).json({ ok: false, error: 'missing id' });

  const catalog = readCatalog();
  if (catalog.some(x => x.id.toLowerCase() === id.toLowerCase())) {
    return res.json({ ok: true, catalog }); // already exists
  }

  catalog.push({ id, name, defaultScope });
  writeCatalog(catalog);

  broadcastDashboards({ type: 'catalog', catalog });

  res.json({ ok: true, catalog });
});

// --------- WS ---------
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

/** @type {Map<string, { ws: WebSocket, id: string, hostname: string, user: string, lastSeen: number }>} */
const agents = new Map();
/** @type {Set<WebSocket>} */
const dashboards = new Set();

function nowMs() { return Date.now(); }

function broadcastDashboards(msg) {
  const payload = JSON.stringify(msg);
  for (const ws of dashboards) {
    if (ws.readyState === WebSocket.OPEN) ws.send(payload);
  }
}

function listAgents() {
  return Array.from(agents.values()).map(a => ({
    id: a.id,
    hostname: a.hostname,
    user: a.user,
    lastSeen: a.lastSeen
  }));
}

function parseQuery(url) {
  const u = new URL(url, 'http://localhost');
  return Object.fromEntries(u.searchParams.entries());
}

wss.on('connection', (ws, req) => {
  const q = parseQuery(req.url || '/');
  const role = q.role || 'agent';

  // Dashboard
  if (role === 'dashboard') {
    dashboards.add(ws);

    ws.send(JSON.stringify({ type: 'packages', packages: readPackages() }));
    ws.send(JSON.stringify({ type: 'catalog', catalog: readCatalog() }));
    ws.send(JSON.stringify({ type: 'agents', agents: listAgents() }));

    ws.on('message', (raw) => {
      let msg;
      try { msg = JSON.parse(raw.toString()); } catch { return; }

      // 1) Installer Upload Deploy (existing)
      if (msg.type === 'install_request') {
        const { targetAgentIds, packageId } = msg;
        const pkgs = readPackages();
        const pkg = pkgs.find(p => p.id === packageId);
        if (!pkg) return;

        for (const agentId of targetAgentIds || []) {
          const a = agents.get(agentId);
          if (!a || a.ws.readyState !== WebSocket.OPEN) continue;

          a.ws.send(JSON.stringify({
            type: 'install_request',
            package: {
              id: pkg.id,
              name: pkg.name,
              version: pkg.version,
              sha256: pkg.sha256,
              sizeBytes: pkg.sizeBytes,
              url: `/packages/${pkg.filename}`,
              typeHint: pkg.typeHint
            }
          }));
        }
      }

      // 2) Winget Deploy (new)
      if (msg.type === 'install_app') {
        const { targetAgentIds, appId, scope } = msg;
        const catalog = readCatalog();
        const item = catalog.find(x => x.id === appId);
        if (!item) return;

        for (const agentId of targetAgentIds || []) {
          const a = agents.get(agentId);
          if (!a || a.ws.readyState !== WebSocket.OPEN) continue;

          a.ws.send(JSON.stringify({
            type: 'install_app',
            app: { id: item.id, name: item.name },
            scope: scope || item.defaultScope || 'user'
          }));
        }
      }
    });

    ws.on('close', () => dashboards.delete(ws));
    return;
  }

  // Agents
  const token = q.token || '';
  if (token !== AGENT_TOKEN) {
    ws.close(1008, 'invalid token');
    return;
  }

  const agentId = q.id || crypto.randomUUID();
  const hostname = q.hostname || 'unknown';
  const user = q.user || '';

  agents.set(agentId, { ws, id: agentId, hostname, user, lastSeen: nowMs() });
  broadcastDashboards({ type: 'agents', agents: listAgents() });

  ws.on('message', (raw) => {
    let msg;
    try { msg = JSON.parse(raw.toString()); } catch { return; }

    const a = agents.get(agentId);
    if (a) a.lastSeen = nowMs();

    if (msg.type === 'status') {
      broadcastDashboards({ type: 'status', agentId, status: msg.status, detail: msg.detail || '' });
    }
  });

  ws.on('close', () => {
    agents.delete(agentId);
    broadcastDashboards({ type: 'agents', agents: listAgents() });
  });
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`[http]   http://0.0.0.0:${PORT}`);
  console.log(`[ws]     ws://0.0.0.0:${PORT} (role=agent|dashboard)`);
  console.log(`[health] http://0.0.0.0:${PORT}/health`);
});

